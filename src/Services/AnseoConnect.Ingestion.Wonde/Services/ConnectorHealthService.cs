using AnseoConnect.Data;
using AnseoConnect.Data.Entities;
using AnseoConnect.Data.MultiTenancy;
using Microsoft.EntityFrameworkCore;

namespace AnseoConnect.Ingestion.Wonde.Services;

/// <summary>
/// Health status for a school's connector.
/// </summary>
public sealed class ConnectorHealth
{
    public Guid SchoolId { get; set; }
    public string ProviderId { get; set; } = string.Empty;
    public string Status { get; set; } = "Unknown"; // Healthy, Warning, Unhealthy
    public DateTimeOffset? LastSuccessfulSyncUtc { get; set; }
    public TimeSpan? TimeSinceLastSync { get; set; }
    public int ConsecutiveFailures { get; set; }
    public decimal ErrorRate { get; set; }
    public int RecentErrorCount { get; set; }
    public string? LastError { get; set; }
    public IReadOnlyList<ConnectorAlert> Alerts { get; set; } = Array.Empty<ConnectorAlert>();
}

/// <summary>
/// Alert generated by health monitoring.
/// </summary>
public sealed class ConnectorAlert
{
    public Guid SchoolId { get; set; }
    public string ProviderId { get; set; } = string.Empty;
    public string AlertType { get; set; } = string.Empty; // SyncFailure, HighErrorRate, StaleSync, MismatchThreshold
    public string Severity { get; set; } = "Warning"; // Info, Warning, Critical
    public string Message { get; set; } = string.Empty;
    public DateTimeOffset DetectedAtUtc { get; set; } = DateTimeOffset.UtcNow;
    public Dictionary<string, object> Details { get; set; } = new();
}

/// <summary>
/// Service for monitoring connector health and generating alerts.
/// </summary>
public interface IConnectorHealthService
{
    /// <summary>
    /// Evaluates health status for a specific school's connector.
    /// </summary>
    Task<ConnectorHealth> EvaluateHealthAsync(Guid schoolId, string providerId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks all schools and generates alerts for those exceeding thresholds.
    /// </summary>
    Task<IReadOnlyList<ConnectorAlert>> CheckAlertsAsync(CancellationToken cancellationToken = default);
}

/// <summary>
/// Implementation of connector health monitoring service.
/// </summary>
public sealed class ConnectorHealthService : IConnectorHealthService
{
    private readonly AnseoConnectDbContext _dbContext;
    private readonly ILogger<ConnectorHealthService> _logger;
    private readonly ITenantContext _tenantContext;

    // Default thresholds (can be made configurable per tenant/school)
    private const int MaxConsecutiveFailures = 3;
    private const decimal MaxErrorRate = 0.05m; // 5%
    private const int StaleSyncHours = 24;
    private const int RecentSyncWindowHours = 24;

    public ConnectorHealthService(
        AnseoConnectDbContext dbContext,
        ILogger<ConnectorHealthService> logger,
        ITenantContext tenantContext)
    {
        _dbContext = dbContext;
        _logger = logger;
        _tenantContext = tenantContext;
    }

    public async Task<ConnectorHealth> EvaluateHealthAsync(
        Guid schoolId,
        string providerId,
        CancellationToken cancellationToken = default)
    {
        var school = await _dbContext.Schools
            .AsNoTracking()
            .Where(s => s.SchoolId == schoolId)
            .FirstOrDefaultAsync(cancellationToken);

        if (school == null)
        {
            throw new InvalidOperationException($"School {schoolId} not found.");
        }

        // Set tenant context
        if (_tenantContext is TenantContext tc)
        {
            tc.Set(school.TenantId, school.SchoolId);
        }

        var health = new ConnectorHealth
        {
            SchoolId = schoolId,
            ProviderId = providerId
        };

        // Get sync state
        var syncState = await _dbContext.SchoolSyncStates
            .AsNoTracking()
            .Where(s => s.TenantId == school.TenantId &&
                       s.SchoolId == schoolId &&
                       s.ProviderId == providerId)
            .ToListAsync(cancellationToken);

        // Get recent sync runs (last 24 hours)
        var recentWindow = DateTimeOffset.UtcNow.AddHours(-RecentSyncWindowHours);
        var recentSyncRuns = await _dbContext.SyncRuns
            .AsNoTracking()
            .Where(r => r.TenantId == school.TenantId &&
                       r.SchoolId == schoolId &&
                       r.ProviderId == providerId &&
                       r.StartedAtUtc >= recentWindow)
            .OrderByDescending(r => r.StartedAtUtc)
            .ToListAsync(cancellationToken);

        if (!recentSyncRuns.Any())
        {
            // No recent syncs - check if there should be
            var lastSync = await _dbContext.SyncRuns
                .AsNoTracking()
                .Where(r => r.TenantId == school.TenantId &&
                           r.SchoolId == schoolId &&
                           r.ProviderId == providerId)
                .OrderByDescending(r => r.StartedAtUtc)
                .FirstOrDefaultAsync(cancellationToken);

            health.Status = "Unhealthy";
            health.LastSuccessfulSyncUtc = lastSync?.CompletedAtUtc;
            health.TimeSinceLastSync = lastSync?.CompletedAtUtc != null
                ? DateTimeOffset.UtcNow - lastSync.CompletedAtUtc.Value
                : null;

            if (health.TimeSinceLastSync > TimeSpan.FromHours(StaleSyncHours))
            {
                health.Alerts = new[]
                {
                    new ConnectorAlert
                    {
                        SchoolId = schoolId,
                        ProviderId = providerId,
                        AlertType = "StaleSync",
                        Severity = "Warning",
                        Message = $"No sync activity for {health.TimeSinceLastSync.Value.TotalHours:F1} hours",
                        Details = new Dictionary<string, object>
                        {
                            ["HoursSinceLastSync"] = health.TimeSinceLastSync.Value.TotalHours
                        }
                    }
                };
            }

            return health;
        }

        // Analyze recent syncs
        var successfulSyncs = recentSyncRuns.Where(r => r.Status == "SUCCEEDED").ToList();
        var failedSyncs = recentSyncRuns.Where(r => r.Status == "FAILED").ToList();

        health.LastSuccessfulSyncUtc = successfulSyncs.FirstOrDefault()?.CompletedAtUtc;
        health.TimeSinceLastSync = health.LastSuccessfulSyncUtc != null
            ? DateTimeOffset.UtcNow - health.LastSuccessfulSyncUtc.Value
            : null;

        // Calculate error rate
        var totalRecords = recentSyncRuns.Sum(r => r.Metrics.Sum(m => m.InsertedCount + m.UpdatedCount + m.SkippedCount + m.ErrorCount));
        var errorCount = recentSyncRuns.Sum(r => r.Metrics.Sum(m => m.ErrorCount)) + failedSyncs.Count;
        health.ErrorRate = totalRecords > 0 ? (decimal)errorCount / totalRecords : 0;
        health.RecentErrorCount = errorCount;

        // Get consecutive failures from sync state
        var overallConsecutiveFailures = syncState
            .Select(s => s.ConsecutiveFailures)
            .DefaultIfEmpty(0)
            .Max();

        health.ConsecutiveFailures = overallConsecutiveFailures;
        health.LastError = syncState
            .Where(s => !string.IsNullOrEmpty(s.LastError))
            .Select(s => s.LastError)
            .FirstOrDefault();

        // Determine status
        var alerts = new List<ConnectorAlert>();

        if (health.ConsecutiveFailures >= MaxConsecutiveFailures)
        {
            health.Status = "Unhealthy";
            alerts.Add(new ConnectorAlert
            {
                SchoolId = schoolId,
                ProviderId = providerId,
                AlertType = "SyncFailure",
                Severity = "Critical",
                Message = $"{health.ConsecutiveFailures} consecutive sync failures",
                Details = new Dictionary<string, object>
                {
                    ["ConsecutiveFailures"] = health.ConsecutiveFailures,
                    ["LastError"] = health.LastError ?? "Unknown"
                }
            });
        }
        else if (health.ErrorRate > MaxErrorRate)
        {
            health.Status = health.ConsecutiveFailures > 0 ? "Unhealthy" : "Warning";
            alerts.Add(new ConnectorAlert
            {
                SchoolId = schoolId,
                ProviderId = providerId,
                AlertType = "HighErrorRate",
                Severity = "Warning",
                Message = $"Error rate {health.ErrorRate:P2} exceeds threshold {MaxErrorRate:P2}",
                Details = new Dictionary<string, object>
                {
                    ["ErrorRate"] = health.ErrorRate,
                    ["ErrorCount"] = health.RecentErrorCount,
                    ["Threshold"] = MaxErrorRate
                }
            });
        }
        else if (health.TimeSinceLastSync > TimeSpan.FromHours(StaleSyncHours))
        {
            health.Status = "Warning";
            alerts.Add(new ConnectorAlert
            {
                SchoolId = schoolId,
                ProviderId = providerId,
                AlertType = "StaleSync",
                Severity = "Warning",
                Message = $"No successful sync in {health.TimeSinceLastSync.Value.TotalHours:F1} hours",
                Details = new Dictionary<string, object>
                {
                    ["HoursSinceLastSync"] = health.TimeSinceLastSync.Value.TotalHours
                }
            });
        }
        else
        {
            health.Status = "Healthy";
        }

        health.Alerts = alerts;
        return health;
    }

    public async Task<IReadOnlyList<ConnectorAlert>> CheckAlertsAsync(CancellationToken cancellationToken = default)
    {
        var allAlerts = new List<ConnectorAlert>();

        // Get all schools with connectors configured
        var schools = await _dbContext.Schools
            .AsNoTracking()
            .Where(s => !string.IsNullOrEmpty(s.WondeSchoolId)) // For now, only check Wonde
            .ToListAsync(cancellationToken);

        foreach (var school in schools)
        {
            try
            {
                if (_tenantContext is TenantContext tc)
                {
                    tc.Set(school.TenantId, school.SchoolId);
                }

                var health = await EvaluateHealthAsync(school.SchoolId, "WONDE", cancellationToken);
                allAlerts.AddRange(health.Alerts);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to evaluate health for school {SchoolId}", school.SchoolId);
            }
        }

        return allAlerts;
    }
}
